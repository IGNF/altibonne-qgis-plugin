# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Altibonne
                                 A QGIS plugin
 Gestion des profils
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-08
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Gérôme PECHEUR (IGN)
        email                : gerome.pecheur@ign.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtGui import QPainterPath, QColor, QFont, QVector3D
from PyQt5.QtWidgets import QFrame, QVBoxLayout, QGraphicsPathItem, QGraphicsTextItem, QGraphicsEllipseItem, \
    QApplication

from qgis.PyQt.QtWidgets import QGraphicsScene, QGraphicsView,QGraphicsLineItem,QGraphicsRectItem
from qgis._core import QgsPointXY
from qgis.core import QgsGeometry, QgsWkbTypes, QgsPoint,QgsDistanceArea, QgsProject
import math

# Import the code for the dialog
from .altibonne_dialog import AltibonneDialog
from .fonction import *
from .clic_cercle import *

def fusion_points(l1, l2):
    return l1 + l2

def orienter_lignes(sommets_l1, sommets_l2, tol=1e-3):
    p1_start, p1_end = sommets_l1[0], sommets_l1[-1]
    p2_start, p2_end = sommets_l2[0], sommets_l2[-1]

    # Comparer seulement x et y
    if points_egau_xy(p1_end, p2_start, tol):
        # L1 -> L2 sans inversion
        return sommets_l1, sommets_l2
    elif points_egau_xy(p1_end, p2_end, tol):
        # L1 -> L2 inversée
        return sommets_l1, list(reversed(sommets_l2))
    elif points_egau_xy(p1_start, p2_end, tol):
        # L1 inversée -> L2 inversés
        return list(reversed(sommets_l1)), list(reversed(sommets_l2))
    elif points_egau_xy(p1_start, p2_start, tol):
        # L1 inversée -> L2 inversée
        # return list(reversed(sommets_l1)), list(reversed(sommets_l2))
        return list(reversed(sommets_l1)), sommets_l2

    # Pas de point commun sur une extrémité
    return None, None

# le z peut être different pour que 2 troncons soient contigües
def points_egau_xy(p1, p2, tol=1e-3):
    return (
            abs(p1.x() - p2.x()) < tol and
            abs(p1.y() - p2.y()) < tol
    )


# ============================================
class Altibonne:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):

        # Save reference to the QGIS interface

        self.last_mouse_pos = None
        # self.list_z = []
        self.dico_coord = {"x":[],"y":[],"z":[]}
        self.list_coord = []
        self.view = None
        self.line = None
        self.scene = None
        self.layer = None
        self.dlg = None
        self.iface = iface

        self.first_start = True

    def get_coord_selection(self):
        self.dico_coord = {"x": [], "y": [], "z": []}
        features = self.layer.selectedFeatures()

        if len(features) == 1:
            geom = features[0].geometry()
            for p in geom.vertices():
                self.dico_coord["x"].append(p.x())
                self.dico_coord["y"].append(p.y())
                self.dico_coord["z"].append(p.z())
            return self.dico_coord

        if len(features) == 2:
            sommets_l1 = list(features[0].geometry().vertices())
            sommets_l2 = list(features[1].geometry().vertices())

            l1, l2 = orienter_lignes(sommets_l1, sommets_l2)
            if l1 is None or l2 is None:
                self.dlg.label_warning.setText(
                    f"<span style = 'color:red'><b>Les tronçons ne sont pas contiguës</b></span>")

                # renvoie un dictionnaire vide
                return {"x": [], "y": [], "z": []}

            points = fusion_points(l1, l2)

            for p in points:
                self.dico_coord["x"].append(p.x())
                self.dico_coord["y"].append(p.y())
                self.dico_coord["z"].append(p.z())

            return self.dico_coord

    def getZminmax_allselection(self):
        return min(self.dico_coord["z"]),max(self.dico_coord["z"])

    def actualiserSelection(self):
        if not self.dlg.isVisible():
            return
        self.scene.clear()
        self.dico_coord = {"x": [], "y": [], "z": []}
        self.list_coord = self.get_coord_selection()

        # self.layer = self.iface.activeLayer()
        self.dlg.label_nb_points.setText(f"Nombre de points = {0}")
        self.dlg.label_warning.setText("")
        # self.dlg.pushButtonUpDown.setEnabled(False)

        if self.layer.selectedFeatureCount() == 0:
            return
        if self.layer.selectedFeatureCount() > 2:
            self.dlg.label_warning.setText(
                f"<span style = 'color:red'><b>veuillez sélectionner 2 tronçons maximum</b></span>")
            return
        if self.layer.selectedFeatureCount() == 2:
            selection = self.layer.selectedFeatures()
            sel1 = selection[0]
            sel2 = selection[1]
            if not sel1.geometry().touches(sel2.geometry()):
                self.dlg.label_warning.setText(f"<span style = 'color:red'><b>Les tronçons ne sont pas contiguës</b></span>")
                return
        if self.layer.selectedFeatureCount() == 1:
            self.dlg.pushButtonUpDown.setEnabled(True)

        self.dessine_ligne(self.list_coord)

    def changeZ(self):
        if self.dlg.lineEdit_valZ.text() == "0":
            return
        geom_type = self.layer.wkbType()
        geom_type_str = QgsWkbTypes.displayString(geom_type)
        if geom_type_str == "LineStringZ" or geom_type_str == "MultiLineString":
            self.getgeometrie()

    def getgeometrie(self):
        self.layer.startEditing()
        for sel in self.layer.selectedFeatures():
            geometry = sel.geometry()
            new_points = []
            for point in geometry.vertices():
                new_point = QgsPoint(point.x(),point.y(),point.z()+int(self.dlg.lineEdit_valZ.text()))
                new_points.append(new_point)

            new_geometry = QgsGeometry.fromPolyline(new_points)
            self.layer.changeGeometry(sel.id(), new_geometry)
        self.actualiserSelection()

    def dessine_ligne(self,list_coord):
        # self.view.resetTransform()
        self.view.resetTransform()
        self.scene.clear()
        path = QPainterPath()

        marge_haut = 10
        marge_bas = 30
        marge_gauche = 10
        marge_droite = 10
        plage_disponible = self.scene.height() - marge_bas - marge_haut
        largeur_disponible = self.scene.width() - marge_gauche - marge_droite

        # récupération des coordonnées des tronçons sélectionnés
        # self.list_coord = self.get_coord_selection()
        list_x = list_coord["x"]
        list_y = list_coord["y"]
        list_z = list_coord["z"]

        # préparer la mesure de distance adaptée au CRS
        from qgis.core import QgsDistanceArea, QgsPointXY, QgsProject
        d = QgsDistanceArea()
        d.setSourceCrs(self.layer.crs(), QgsProject.instance().transformContext())
        if self.layer.crs().isGeographic():
            d.setEllipsoid(self.layer.crs().ellipsoidAcronym())

        # distances cumulées entre points
        distances_cumulees = [0]
        for i in range(1, len(list_x)):
            p1 = QgsPointXY(list_x[i - 1], list_y[i - 1])
            p2 = QgsPointXY(list_x[i], list_y[i])
            distance = d.measureLine(p1, p2)
            distances_cumulees.append(distances_cumulees[-1] + distance)
        distance_totale = distances_cumulees[-1] or 1  # éviter division par zéro

        # min/max Z
        zmin, zmax = self.getZminmax_allselection()

        # indices de fin de ligne pour cercles rouges
        indice_fin_ligne = []
        count = 0
        for ligne in self.layer.selectedFeatures():
            nb_points = len(list(ligne.geometry().vertices()))
            count += nb_points
            indice_fin_ligne.append(count)

        # DESSIN
        for i, z_point in enumerate(list_z):
            pos_x = marge_gauche + (distances_cumulees[i] / distance_totale) * largeur_disponible
            if zmax != zmin:
                pos_z = marge_haut + plage_disponible * (1 - (z_point - zmin) / (zmax - zmin))
            else:
                pos_z = self.scene.height() / 2
            # LIGNE
            if i == 0:
                path.moveTo(pos_x, pos_z)
            else:
                path.lineTo(pos_x, pos_z)

            # CERCLES ROUGE
            if i in [0, indice_fin_ligne[0] - 1]:  # début et fin du premier tronçon
                # cercle = QGraphicsEllipseItem(-5, -5, 10, 10)
                cercle = CercleClickable(-5, -5, 10, 10)
                cercle.setBrush(QColor(255, 0, 0))
            # CERCLES VERT
            else:
                # cercle = QGraphicsEllipseItem(-2.5, -2.5, 5, 5)
                cercle = CercleClickable(-2.5, -2.5, 5, 5)
                cercle.setBrush(QColor(0, 255, 0))
            cercle.setPos(pos_x, pos_z)
            self.scene.addItem(cercle)

            # texte altitude
            altitude_text = QGraphicsTextItem(str(z_point))
            font = QFont('Arial', 8, QFont.Bold)
            altitude_text.setFont(font)
            altitude_text.setPos(pos_x - 15, pos_z)
            self.scene.addItem(altitude_text)

        # ajouter polyline
        polyline_item = QGraphicsPathItem(path)
        polyline_item.setPen(QColor(255, 0, 0))
        self.scene.addItem(polyline_item)

        self.dlg.label_nb_points.setText(f"Nombre de points = {len(list_z)}")



    def initGui(self):
        pass

    def unload(self):
        pass


    def creerscene(self):
        self.scene = QGraphicsScene(self.dlg)
        self.layoutscene = QVBoxLayout()
        # self.scene.setSceneRect(0, 0, 200, 200)  # Définir la taille de la scène
        # self.add_scene_border()

        # Créer une vue pour afficher la scène
        self.view = QGraphicsView(self.scene,self.dlg)
        # deplacement dans la vue
        self.view.setDragMode(QGraphicsView.ScrollHandDrag)
        self.view.setStyleSheet("QGraphicsView { border: 3px solid black; }")
        self.view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.dlg.setContentsMargins(0, 40, 10, 0)


        # self.dlg.verticalLayout_vue.addWidget(self.view)
        self.layoutscene.addWidget(self.view)


        # Définir le layout principal de dlg
        # self.dlg.setLayout(self.dlg.verticalLayout_vue)
        self.dlg.setLayout(self.layoutscene)




    def add_scene_border(self):
        # Créer un rectangle qui servira de contour autour de la scène
        scene_rect = self.scene.sceneRect()
        border_item = QGraphicsRectItem(scene_rect)

        # # Appliquer un style au contour (bordure)
        border_item.setPen(Qt.black)  # Bordure noire
        border_item.setBrush(Qt.transparent)  # Fond transparent
        self.scene.addItem(border_item)

    # def creerline(self):
    #     self.line = QGraphicsLineItem()
    #     # self.line.setLine(20, 20, 50, 90)
    #     self.scene.addItem(self.line)

    def update_line_position(self):

        # Adapter la ligne à la taille de la fenêtre
        # Par exemple, la ligne pourrait s'étirer en fonction de la taille de la scène
        # scene_rect = self.scene.sceneRect()
        # print("taille scene = ",scene_rect.height())
        # print("pos scene = ",self.scene.sceneRect())
        self.scene.setSceneRect(0, 0, self.view.width(), self.view.height())  # Définir la taille de la scène

        # Appliquer un style au contour (bordure)
        # scene_rect = self.scene.sceneRect()
        # border_item = QGraphicsRectItem(scene_rect)
        # border_item.setPen(Qt.black)  # Bordure noire
        # border_item.setBrush(Qt.transparent)  # Fond transparent
        # self.scene.addItem(border_item)

        # self.line.setLine(0, 0, self.view.width(), self.view.height())



    def on_resize(self, event):
        self.layer = self.iface.activeLayer()
        self.actualiserSelection()
        # Mettre à jour la ligne et la scène
        if self.layer.selectedFeatureCount() == 0:
            return
        # self.scene.setSceneRect(-10, 0, self.view.width(), self.view.height())
        self.scene.setSceneRect(0, 0, self.view.width(), self.view.height())
        if not self.list_coord:  # None ou dictionnaire vide
            event.accept()
            return
        self.dessine_ligne(self.list_coord)
        event.accept()

    # def mousepressevent(self,event):
    #     if event.button() == Qt.MiddleButton:
    #         self.last_mouse_pos = event.pos()
    #
    #     event.accept()

    def mousemoveevent(self,event):
        if self.last_mouse_pos:
            # Calculer le déplacement de la souris
            delta = event.pos() - self.last_mouse_pos
            self.last_mouse_pos = event.pos()  # Mettre à jour la position de la souris

            # Déplacer la scène (ou vue) en fonction du mouvement de la souris
            self.view.translate(delta.x(), delta.y())  # Déplacer la scène sur l'axe X et Y
            event.accept()

    def mousereleaseevent(self,event):
        if event.button() == Qt.MiddleButton:
            self.last_mouse_pos = None  # Réinitialiser la position de la souris
            event.accept()

    def molette(self,event):
        scale = 1.5
        # if event.angleDelta().y() > 0:
        #     self.view.scale(scale, scale)  # Zoom avant
        # else:
        #     self.view.scale(1 / scale, 1 / scale)
        # event.accept()

        # position du curseur dans la scene
        cursor_pos = self.view.mapToScene(event.pos())
        # appliquer le zoom centré sur ce point
        if event.angleDelta().y() > 0:  # molette vers l’avant
            zoom = scale
        else:
            zoom = 1 / scale
        self.view.scale(zoom, zoom)
        # ajuster le centre pour que le point du curseur reste au même endroit
        new_center = cursor_pos
        self.view.centerOn(new_center)
        event.accept()

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        # if self.first_start == True:
        #     self.first_start = False
        self.dlg = AltibonneDialog()

        self.layer = self.iface.activeLayer()

        # le plugin espace co ne remet pas le curseur par defaut
        # donc je le fais ici.
        while QApplication.overrideCursor() is not None:
            QApplication.restoreOverrideCursor()

        self.dlg.label_nb_points.setText(f"Nombre de points = {0}")
        self.dlg.lineEdit_valZ.setText("0")
        self.dlg.label_warning.setText("")

        self.iface.mapCanvas().selectionChanged.connect(self.actualiserSelection)
        self.creerscene()


        self.dlg.pushButtonUpDown.clicked.connect(self.changeZ)

        self.dlg.resizeEvent = self.on_resize
        # self.dlg.mousePressEvent = self.mousepressevent
        self.dlg.mouseMoveEvent = self.mousemoveevent
        self.dlg.mouseReleaseEvent = self.mousereleaseevent
        self.dlg.wheelEvent = self.molette

        self.dlg.setParent(self.iface.mainWindow())
        self.dlg.setWindowFlags(Qt.Dialog | Qt.WindowTitleHint | Qt.WindowCloseButtonHint)
        # show the dialog
        self.dlg.show()
        self.actualiserSelection()
        # Run the dialog event loop
        # result = self.dlg.exec_()
        # # See if OK was pressed
        # if result:
        #     # Do something useful here - delete the line containing pass and
        #     # substitute with your code.
        #     pass
